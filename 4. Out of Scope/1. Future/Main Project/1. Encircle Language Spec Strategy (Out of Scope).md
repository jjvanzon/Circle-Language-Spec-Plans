Encircle Language Spec | Strategy (Out of Scope)
================================================


Introduction
------------

This document describes the strategy and goals of the project *Encircle Language Spec*, that were deemed out of scope.

The content was just moved here from the document *Encircle Language Spec Strategy*.

[...] There are other ideas in it about programming language in general, but those are not as prominent.


Higher Goal
-----------

One of my worries is, that I have not learned enough constructs, that exist in the world, to really make a unified language for all digital objects. The language was supposed to give a different view onto any digital data: folders, scheduled tasks, object oriented code, the web, databases or any complicated referential structure. It is supposed to combine all of it into a single landscape in a single language, and serve as an entry-point for all other types of digital expression, such as opening data in the app it is intended for, displaying that view on top of the diagram, that is a map of everything going on inside the computer.


Goal of the Language
--------------------

Here are some goals of the new language:

- ~ Gain instant insight into complex referential structures, hopefully to a degree that no other way of diagramming ever could.
- ~ *Anything* digital can be translated to such a diagram, because most things digital are just referential structures.
- ~ Make it easier to program software.
- ~ Make *programming* the same as *using* a computer.
- ~ Offer an instant user interface for anything digital and traditionally invisible.
- ~ The invisibility of digital connections, that software developers and ICT infrastructure engineers only imagine in their head, are now visualized on screen.

What might prove that the diagram language fails:

- ~ That the diagram expression does not simplify the view on complex referential structures, but that it will still look like an unoverviewable bunch of wiring.
- ~ Do take comfort in the fact, that if this goal is not reached, the language might still have other uses.

The language has more goals, but the goals above might be the more important ones.


Later Goal
----------

- ~ Programming: Essential Libraries: Math, Integrate  
    (2020-01: Programming things is not really a goal right now.)
-----
- ~ Programming: Program a version (part done)
- ~ Documentation: Added Concept: Internet as a Single Computer: Physical & Logical, Caching
- ~ Documentation: Added Concept: Security
- ~ Documentation: Added Concept: Compilation
- ~ Documentation: Advanced Input/Output
- ~ Documentation: Added Paradigm: Querying
- ~ Documentation: Added Paradigm: Concepts

Programming: This was a point at which, it seemed a good plan to program some software. While not all pieces of the language were designed yet, some experimental things have been programmed. One fear was: making something, that would later be thrown away, would the language change completely. But the base of the language was not expected to change drastically. Another fear was to lose time programming, that was better spent on the language design. The hope was, that a working version would tell where the big problems are would indicate solutions to problems initially not possible to get your head around.

That is where it's at right now. The other steps in the list above are possible future steps, but possibly not necessary.


Theme Picking
-------------

### Rules

- No projects anymore for repairing older material & update working methods

### Specific Limitations

#### Do not Work Out the 'Aspects' Topic First

*Note that the concept construct is still in scope of the Encircle Language Spec project, though a postponed work item. The descriptions about it here, seem too confusing to share, though.*

What you can see, is that the power of software system and the new computer language might be very dependent on the workings of the *concept* programming construct. They are pretty much the 'aspects' from 'aspect oriented programming'. Much of my ideas for software consists of *concept* modules, such as *Coding Concepts, Data Concepts, Internet Concepts, Controls Concepts* and *Editing & Authoring Concepts*. Those are all power-enhancements of software, that can be immediately applied to any system without any further programming. (Perhaps only when the base of the software is a structure of 'entities' with relations between each other.)

It is quite tempting to start working out how implementation of concept modules works in the new computer language, because it may be an important idea, not adequately worked out yet. But even though it seems important to work out first, the pragmatic thing to do is still to first work out the ideas, that are already clear to me. Because, that will go the fastest, and is more in the line of the general goal I have with the projects I do: my ideas more easily picked up by others.  
And also: when those ideas are clear on paper, they are more crystal clear in my head, and possibly during the working out of those ideas, the other ideas, not yet as clear, will have become clearer, by having the chance to settle.

So the bottom line is: after the current project do not work out the important principle of concepts, but work out the ideas, that are easy to work out, because they are already clear to me.


Productive Writing
------------------

### Writing Efficiently

- [...] level or knowledge of the reader:
    - Try not to worry too much about the implications of *automatic containment*. [...]

### Concepts & Principles

Earlier, the principles that need to be present in the base code, were separated from the *concepts*, that could be programmed using the base code itself. But from a functional point of view it does not matter how much can be left out of the base code. How as much as possible can be left out of the base code, can be pondered about as the product is being further developed. The subjects are grouped by functionality. The functionality, that needs to be present in the base code, is spread out all over the functional needs. From a functional point of view it does not really matter whether something is implemented as a plugged-in concept or as an intrinsic language principle.

### How Much Designing Before You Implement

You might want to see a concept running, in a conceptual implementation, to be able to see where the design fails. That is kind of a flaw in designing everything first. You might not be able work out everything in theory first. The design may be imperfect, until it is proven by a conceptual version.  Working out too much in theory can lead to results inefficiently, compared to working out the idea roughly, and then building a conceptual version.  
Human beings may much more easily identify flaws in running system, than they can before anything has even been made.

An experimental new version of the new computer language could be created at one point, that supports all the principles in its minimal form, just to see how it will look in action. The left-over problems may become apparent quickly then. And an experimental implementation may also *prove* the concepts. It probably gives you a clearer picture of the language, which may help to complete other topics.

But when the next conceptual implementation will be created is unclear. That would be the project *Program Base Code*.

Sometimes it can be demotivating, that making the design takes so much time and seems to render so little result. But it may be important, that the ideas could be picked up by others. More arguably it may be important, that it becomes the *final* design of the base, not an *intermediate* one again, in which important things have been left out, that I know I am going to have to do over again. I left that idea behind, when I decided it did not need to be perfect.